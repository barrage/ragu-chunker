use crate::error::ChonkitError;
use serde::{Deserialize, Serialize};
use uuid::Uuid;

use super::provider::Identity;

// Collection (identity vector) properties.

pub const COLLECTION_ID_PROPERTY: &str = "collection_id";
pub const COLLECTION_NAME_PROPERTY: &str = "name";
pub const COLLECTION_SIZE_PROPERTY: &str = "size";
pub const COLLECTION_EMBEDDING_PROVIDER_PROPERTY: &str = "embedding_provider";
pub const COLLECTION_EMBEDDING_MODEL_PROPERTY: &str = "embedding_model";
pub const COLLECTION_GROUPS_PROPERTY: &str = "groups";

// Vector payload properties.

pub const CONTENT_PROPERTY: &str = "content";
pub const DOCUMENT_ID_PROPERTY: &str = "document_id";

/// Used by vector databases.
#[derive(Debug, Serialize, Deserialize, Default, utoipa::ToSchema)]
#[serde(rename_all(serialize = "camelCase"))]
pub struct VectorCollection {
    /// Unique collection identifier generated by the (non-vector) database.
    #[serde(alias = "collection_id")]
    pub id: Uuid,

    /// Unique collection name.
    pub name: String,

    /// Collection vector size
    pub size: usize,

    /// Embedding provider used for the embedding_model.
    pub embedding_provider: String,

    /// Embedding model used for the collection, has to be available on the embedding provider.
    pub embedding_model: String,

    /// Collection user groups.
    pub groups: Option<Vec<String>>,
}

impl VectorCollection {
    pub fn new(
        id: Uuid,
        name: String,
        size: usize,
        embedding_provider: String,
        embedding_model: String,
        groups: Option<Vec<String>>,
    ) -> Self {
        Self {
            id,
            name,
            size,
            embedding_provider,
            embedding_model,
            groups,
        }
    }

    pub fn with_id(mut self, id: Uuid) -> Self {
        self.id = id;
        self
    }

    pub fn with_name(mut self, name: String) -> Self {
        self.name = name;
        self
    }

    pub fn with_size(mut self, size: usize) -> Self {
        self.size = size;
        self
    }

    pub fn with_embedding_provider(mut self, provider: String) -> Self {
        self.embedding_provider = provider;
        self
    }

    pub fn with_embedding_model(mut self, model: String) -> Self {
        self.embedding_model = model;
        self
    }

    pub fn with_groups(mut self, groups: Option<Vec<String>>) -> Self {
        self.groups = groups;
        self
    }
}

#[derive(Debug, Serialize)]
pub struct CreateVectorCollection<'a> {
    pub collection_id: Uuid,
    pub name: &'a str,
    pub size: usize,
    pub embedding_provider: &'a str,
    pub embedding_model: &'a str,
    pub groups: Option<Vec<String>>,
}

impl<'a> CreateVectorCollection<'a> {
    pub fn new(
        id: Uuid,
        name: &'a str,
        size: usize,
        embedding_provider: &'a str,
        embedding_model: &'a str,
        groups: Option<Vec<String>>,
    ) -> Self {
        Self {
            collection_id: id,
            name,
            size,
            embedding_provider,
            embedding_model,
            groups,
        }
    }
}

impl<'a> From<&'a VectorCollection> for CreateVectorCollection<'a> {
    fn from(value: &'a VectorCollection) -> Self {
        Self {
            collection_id: value.id,
            name: &value.name,
            size: value.size,
            embedding_provider: &value.embedding_provider,
            embedding_model: &value.embedding_model,
            groups: value.groups.clone(),
        }
    }
}

#[derive(Debug, Serialize, utoipa::ToSchema)]
pub struct CollectionSearchItem {
    pub content: String,
    pub distance: Option<f64>,
}

/// Vector database operations.
#[async_trait::async_trait]
pub trait VectorDb: Identity {
    /// List available vector collections.
    /// Returns a list of results whose errors indicate that a collection
    /// is not compatible with the current data structures.
    async fn list_vector_collections(&self) -> Vec<Result<VectorCollection, ChonkitError>>;

    /// Create a vector collection.
    ///
    /// * `name`: The name of the collection.
    /// * `size`: Vector size of the collection.
    async fn create_vector_collection(
        &self,
        data: CreateVectorCollection<'_>,
    ) -> Result<(), ChonkitError>;

    /// Update a collection's groups property.
    /// Implementations should take care to completely replace the groups with the new ones.
    ///
    ///
    /// * `collection`: Collection name.
    /// * `groups`: Collection groups that will override the current ones.
    async fn update_collection_groups(
        &self,
        collection: &str,
        groups: Option<Vec<String>>,
    ) -> Result<(), ChonkitError>;

    /// Get collection info.
    ///
    /// * `name`: Collection name.
    async fn get_collection(&self, name: &str) -> Result<VectorCollection, ChonkitError>;

    /// Delete a vector collection.
    ///
    /// * `name`: The name of the collection.
    async fn delete_vector_collection(&self, name: &str) -> Result<(), ChonkitError>;

    /// Perform semantic search.
    ///
    /// * `search`: The query to use as the search vector.
    /// * `collection`: The collection to search in.
    /// * `limit`: Amount of results to return.
    async fn query(
        &self,
        search: Vec<f64>,
        collection: &str,
        limit: u32,
        max_distance: Option<f64>,
    ) -> Result<Vec<CollectionSearchItem>, ChonkitError>;

    /// Store the contents and their vectors to the vector storage.
    /// The `contents` and `vectors` inputs are expected to
    /// be 1:1, i.e. the same index into both lists should
    /// yield the contents and their respectful embeddings.
    ///
    /// * `content`: The contents to append to the vectors.
    /// * `vectors`: The vectors to store.
    /// * `collection`: The vector collection to store in.
    async fn insert_embeddings(
        &self,
        document_id: Uuid,
        collection: &str,
        content: &[&str],
        vectors: Vec<Vec<f64>>,
    ) -> Result<(), ChonkitError>;

    /// Delete the vectors tagged with the given `document_id`.
    ///
    /// * `collection`: The collection to delete from.
    /// * `document_id`: The id of the document whose vectors to delete.
    async fn delete_embeddings(
        &self,
        collection: &str,
        document_id: Uuid,
    ) -> Result<(), ChonkitError>;

    /// Returns the amount of vectors tagged with the given `document_id`.
    ///
    /// * `collection`: The collection to count in.
    /// * `document_id`: The id of the document whose vectors to count.
    async fn count_vectors(
        &self,
        collection: &str,
        document_id: Uuid,
    ) -> Result<usize, ChonkitError>;
}
