use super::provider::Identity;
use crate::error::ChonkitError;
use serde::{Deserialize, Serialize};
use uuid::Uuid;

// Collection (identity vector) properties.

pub const COLLECTION_ID_PROPERTY: &str = "collection_id";
pub const COLLECTION_NAME_PROPERTY: &str = "name";
pub const COLLECTION_SIZE_PROPERTY: &str = "size";
pub const COLLECTION_EMBEDDING_PROVIDER_PROPERTY: &str = "embedding_provider";
pub const COLLECTION_EMBEDDING_MODEL_PROPERTY: &str = "embedding_model";
pub const COLLECTION_GROUPS_PROPERTY: &str = "groups";

// Vector payload embedding properties.

// General properties
pub const DOCUMENT_ID_PROPERTY: &str = "document_id";

/// Keep in sync with [CollectionItem].
pub const IMAGE_B64_PROPERTY: &str = "image_b64";
/// Keep in sync with [CollectionItem].
pub const IMAGE_PATH_PROPERTY: &str = "image_path";
/// Keep in sync with [CollectionItem].
pub const IMAGE_DESCRIPTION_PROPERTY: &str = "image_description";

// Text properties
pub const CONTENT_PROPERTY: &str = "content";

/// Vector database operations.
#[async_trait::async_trait]
pub trait VectorDb: Identity {
    /// List available vector collections.
    /// Returns a list of results whose errors indicate that a collection
    /// is not compatible with the current data structures.
    async fn list_vector_collections(&self) -> Vec<Result<VectorCollection, ChonkitError>>;

    /// Create a vector collection.
    ///
    /// * `name`: The name of the collection.
    /// * `size`: Vector size of the collection.
    async fn create_vector_collection(
        &self,
        data: CreateVectorCollection<'_>,
    ) -> Result<(), ChonkitError>;

    /// Update a collection's groups property.
    /// Implementations should take care to completely replace the groups with the new ones.
    ///
    ///
    /// * `collection`: Collection name.
    /// * `groups`: Collection groups that will override the current ones.
    async fn update_collection_groups(
        &self,
        collection: &str,
        groups: Option<Vec<String>>,
    ) -> Result<(), ChonkitError>;

    /// Get collection info.
    ///
    /// * `name`: Collection name.
    async fn get_collection(&self, name: &str) -> Result<VectorCollection, ChonkitError>;

    /// Delete a vector collection.
    ///
    /// * `name`: The name of the collection.
    async fn delete_vector_collection(&self, name: &str) -> Result<(), ChonkitError>;

    /// Perform semantic search.
    ///
    /// * `search`: The query to use as the search vector.
    /// * `collection`: The collection to search in.
    /// * `limit`: Amount of results to return.
    async fn query(
        &self,
        search: Vec<f64>,
        collection: &str,
        limit: u32,
        max_distance: Option<f64>,
    ) -> Result<Vec<CollectionSearchItem>, ChonkitError>;

    /// Store the contents and their vectors to the vector storage.
    /// For text embeddings the `contents` and `vectors` inputs are expected to
    /// be 1:1, i.e. the same index into both lists should
    /// yield the contents and their respectful embeddings.
    ///
    /// * `insert`: The insert payload.
    async fn insert_embeddings(&self, insert: CollectionItemInsert<'_>)
        -> Result<(), ChonkitError>;

    /// Delete the vectors tagged with the given `document_id`.
    ///
    /// * `collection`: The collection to delete from.
    /// * `document_id`: The id of the document whose vectors to delete.
    async fn delete_embeddings(
        &self,
        collection: &str,
        document_id: Uuid,
    ) -> Result<(), ChonkitError>;

    /// Returns the amount of vectors tagged with the given `document_id`.
    ///
    /// * `collection`: The collection to count in.
    /// * `document_id`: The id of the document whose vectors to count.
    async fn count_vectors(
        &self,
        collection: &str,
        document_id: Uuid,
    ) -> Result<usize, ChonkitError>;
}

/// Used by vector databases to represent a collection with an identity vector.
///
/// Always make sure this struct follows the structure of [CreateVectorCollection]
/// as that one is used for inserting collections and will determine the ID vector's
/// properties.
#[derive(Debug, Serialize, Deserialize, Default, utoipa::ToSchema)]
#[serde(rename_all(serialize = "camelCase"))]
pub struct VectorCollection {
    /// Unique collection identifier generated by the (non-vector) database.
    pub collection_id: Uuid,

    /// Unique collection name.
    pub name: String,

    /// Collection vector size
    pub size: usize,

    /// Embedding provider used for the embedding_model.
    pub embedding_provider: String,

    /// Embedding model used for the collection, has to be available on the embedding provider.
    pub embedding_model: String,

    /// Collection user groups.
    pub groups: Option<Vec<String>>,
}

impl VectorCollection {
    pub fn new(
        id: Uuid,
        name: String,
        size: usize,
        embedding_provider: String,
        embedding_model: String,
        groups: Option<Vec<String>>,
    ) -> Self {
        Self {
            collection_id: id,
            name,
            size,
            embedding_provider,
            embedding_model,
            groups,
        }
    }

    pub fn with_id(mut self, id: Uuid) -> Self {
        self.collection_id = id;
        self
    }

    pub fn with_name(mut self, name: String) -> Self {
        self.name = name;
        self
    }

    pub fn with_size(mut self, size: usize) -> Self {
        self.size = size;
        self
    }

    pub fn with_embedding_provider(mut self, provider: String) -> Self {
        self.embedding_provider = provider;
        self
    }

    pub fn with_embedding_model(mut self, model: String) -> Self {
        self.embedding_model = model;
        self
    }

    pub fn with_groups(mut self, groups: Option<Vec<String>>) -> Self {
        self.groups = groups;
        self
    }

    /// This implementation must always take care to follow the structure of
    /// [CreateVectorCollection] since they share the same properties.
    pub fn query_properties() -> &'static [&'static str] {
        &[
            COLLECTION_ID_PROPERTY,
            COLLECTION_NAME_PROPERTY,
            COLLECTION_SIZE_PROPERTY,
            COLLECTION_EMBEDDING_PROVIDER_PROPERTY,
            COLLECTION_EMBEDDING_MODEL_PROPERTY,
            COLLECTION_GROUPS_PROPERTY,
        ]
    }
}

/// Used by vector databases to create a collection with an identity vector.
///
/// Must always be kept in sync with [VectorCollection].
#[derive(Debug, Serialize)]
pub struct CreateVectorCollection<'a> {
    pub collection_id: Uuid,
    pub name: &'a str,
    pub size: usize,
    pub embedding_provider: &'a str,
    pub embedding_model: &'a str,
    pub groups: Option<Vec<String>>,
}

impl<'a> CreateVectorCollection<'a> {
    pub fn new(
        id: Uuid,
        name: &'a str,
        size: usize,
        embedding_provider: &'a str,
        embedding_model: &'a str,
        groups: Option<Vec<String>>,
    ) -> Self {
        Self {
            collection_id: id,
            name,
            size,
            embedding_provider,
            embedding_model,
            groups,
        }
    }
}

impl<'a> From<&'a VectorCollection> for CreateVectorCollection<'a> {
    fn from(value: &'a VectorCollection) -> Self {
        Self {
            collection_id: value.collection_id,
            name: &value.name,
            size: value.size,
            embedding_provider: &value.embedding_provider,
            embedding_model: &value.embedding_model,
            groups: value.groups.clone(),
        }
    }
}

#[derive(Debug)]
pub struct CollectionItemInsert<'a> {
    /// Specifies the collection to insert to.
    pub collection: &'a str,

    /// The payload to insert.
    pub payload: CollectionItemInsertPayload<'a>,
}

impl<'a> CollectionItemInsert<'a> {
    pub fn new_text(
        document_id: Uuid,
        collection: &'a str,
        content: &'a [&'a str],
        vectors: Vec<Vec<f64>>,
    ) -> Self {
        Self {
            collection,
            payload: CollectionItemInsertPayload::Text {
                items: content
                    .iter()
                    .map(|content| CollectionItemText {
                        document_id,
                        content,
                    })
                    .collect(),
                vectors,
            },
        }
    }

    pub fn new_image(
        document_id: Option<Uuid>,
        collection: &'a str,
        image_b64: &'a str,
        image_path: &'a str,
        image_description: Option<&'a str>,
        vector: Vec<f64>,
    ) -> Self {
        Self {
            collection,
            payload: CollectionItemInsertPayload::Image {
                item: CollectionItemImage {
                    document_id,
                    image_b64,
                    image_path,
                    image_description,
                },
                vector,
            },
        }
    }
}

/// Transport DTO for inserting collection items.
///
/// The `item` fields are payloads, i.e. the original chunks/blobs.
///
/// The `vector(s)` are the embeddings.
#[derive(Debug)]
pub enum CollectionItemInsertPayload<'a> {
    Text {
        items: Vec<CollectionItemText<'a>>,
        vectors: Vec<Vec<f64>>,
    },
    Image {
        item: CollectionItemImage<'a>,
        vector: Vec<f64>,
    },
}

/// This structure must always be kept in sync with [CollectionItem] and its corresponding flattened
/// [CollectionItemPayload::Text].
#[derive(Debug, Serialize)]
pub struct CollectionItemText<'a> {
    pub document_id: Uuid,
    pub content: &'a str,
}

/// This structure must always be kept in sync with [CollectionItem] and its corresponding flattened
/// [CollectionItemPayload::Image].
#[derive(Debug, Serialize)]
pub struct CollectionItemImage<'a> {
    pub document_id: Option<Uuid>,
    pub image_b64: &'a str,
    pub image_path: &'a str,
    pub image_description: Option<&'a str>,
}

/// Contains the collection item payload and the distance to the query vector.
#[derive(Debug, Serialize, utoipa::ToSchema)]
pub struct CollectionSearchItem {
    pub distance: Option<f64>,
    pub item: CollectionItem,
}

impl CollectionSearchItem {
    pub fn new(item: CollectionItem, distance: Option<f64>) -> Self {
        Self { distance, item }
    }
}

/// Properties of a vector obtained when querying.
#[derive(Debug, Deserialize, Serialize, utoipa::ToSchema)]
pub struct CollectionItem {
    pub document_id: Option<Uuid>,
    #[serde(flatten)]
    pub payload: CollectionItemPayload,
}

impl CollectionItem {
    pub fn query_properties() -> &'static [&'static str] {
        &[
            DOCUMENT_ID_PROPERTY,
            CONTENT_PROPERTY,
            // IMAGE_B64_PROPERTY,
            IMAGE_PATH_PROPERTY,
            IMAGE_DESCRIPTION_PROPERTY,
        ]
    }
}

#[derive(Debug, Deserialize, Serialize, utoipa::ToSchema)]
#[serde(untagged)]
pub enum CollectionItemPayload {
    Text {
        content: String,
    },
    Image {
        image_b64: Option<String>,
        image_path: String,
        image_description: Option<String>,
    },
}

#[cfg(test)]
impl CollectionItemPayload {
    pub fn as_image_b64(&self) -> String {
        match self {
            CollectionItemPayload::Image {
                image_b64,
                image_path: _,
                image_description: _,
            } => image_b64.as_ref().unwrap().clone(),
            _ => panic!("not an image"),
        }
    }

    pub fn as_content(&self) -> String {
        match self {
            CollectionItemPayload::Text { content } => content.clone(),
            _ => panic!("not text"),
        }
    }
}
